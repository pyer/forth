#!help
To be continued

STANDARD
Nearly conform to
Forth 200x Standardisation Committee
Forth 2012 RC2
13th November, 2013


! ( x a-addr -- )
Store x at a-addr.
See also: @

# ( ud1 -- ud2 )
Divide ud1 by the number in BASE giving the quotient ud2 and the remainder n. (n is the
least significant digit of ud1.) Convert n to external form and add the resulting character
to the beginning of the pictured numeric output string. An ambiguous condition exists if
# executes outside of a <# #> delimited number conversion.
See also: #> #S <#

#>
( xd -- c-addr u )
Drop xd. Make the pictured numeric output string available as a character string. c-addr
and u specify the resulting character string. A program may replace characters within
the string.
See also: # #S <#

#S ( xd -- c-addr u )
Drop xd. Make the pictured numeric output string available as a character string. c-addr
and u specify the resulting character string. A program may replace characters within
the string.
See also: #> # <#

$CWD

$EUID

$GID

$HOME

$PID

$UID

$USER

' ( " spaces name" -- xt )
Skip leading space delimiters. Parse name delimited by a space. Find name and return
xt, the execution token for name. An ambiguous condition exists if name is not found.
When interpreting, ’ xyz EXECUTE is equivalent to xyz.
See also: EXECUTE FIND

( ( "ccc paren " -- )
Parse ccc delimited by ')' (right parenthesis). ( is an immediate word.
The number of characters in ccc may be zero to the number of characters in the parse area.
( and ) must be on the same line. If not, the input buffer is not refilled.

* ( n1 n2 -- n3 )
Multiply n1 by n2 giving the product n3.

+ ( n1 n2 -- n3 )
Add n2 to n1 giving the sum n3.

+! ( n a-addr -- )
Add n to the single-cell number at a-addr.

, ( x -- )
Reserve one cell of data space and store x in the cell. If the data-space pointer is aligned
when , begins execution, it will remain aligned when , finishes execution. An ambigu-
ous condition exists if the data-space pointer is not aligned prior to execution of ,.

- ( n1 n2 -- n3 )
Subtract n2 from n1 giving the difference n3.

. ( n -- )
Display n in free field format.
Free-field number display uses the characters described in digit conversion, without leading zeros, in a field
the exact size of the converted string plus a trailing space. If a number is zero, the least significant digit is
not considered a leading zero. If the number is negative, a leading minus sign is displayed.
See also: ." .R

." ( "ccc quote " -- )
Parse and display ccc delimited by '"' (double-quote).
See also: . .R

.COPYRIGHT ( -- )
Display copyright information.

.LICENSE ( -- )
Display license information.
The basic PF system is licensed under the terms of the LGPL (Lesser GNU Public License)

.R ( n1 n2 -- )
Display n1 right aligned in a field n2 characters wide. If the number of characters required
to display n1 is greater than n2, all digits are displayed with no leading spaces in a field
as wide as necessary.
See also: . ."

.S ( -- )
Display the stack contents.

.STATUS
Display the status of the current PF system.

.VERSION ( -- )
Display the version of the current PF system.

.WARRANTY ( -- )
Display a warranty information.
The basic PF system is licensed under the terms of the LGPL (Lesser GNU Public License)
which exludes almost any liabilities whatsoever - however loadable binary modules may
hook into the system and their functionality may have different WARRANTY infos.

/ ( n1 n2 -- n3 )
Divide n1 by n2, giving the single-cell quotient n3.
An ambiguous condition exists if n2 is zero.

/MOD ( n1 n2 -- r q )
Divide n1 by n2, giving the single-cell remainder r and the single-cell quotient q.
An ambiguous condition exists if n2 is zero.

0 ( -- 0 )
Constant.

0< ( n -- flag )
flag is true if and only if n is less than zero.

0<> ( n -- flag )
flag is true if and only if n is different from zero.

0= ( n -- flag )
flag is true if and only if n is equal to zero.

0> ( n -- flag )
flag is true if and only if n is greater than zero.

1 ( -- 1 )
Constant.

1+ ( n1 -- n2 )
Add one (1) to n1 giving the sum n2.

1- ( n1 -- n2 )
Subtract one (1) from n1 giving the difference n2.

2 ( -- 2 )
Constant.

2* ( n1 -- n2 )
n2 is the result of shifting n1 one bit toward the most-significant bit, filling the
vacated least-significant bit with zero.

2+ ( n1 -- n2 )
Add two (2) to n1 giving the sum n2.

2- ( n1 -- n2 )
Subtract two (2) from n1 giving the difference n2.

2/ ( n1 -- n2 )
n2 is the result of shifting n1 one bit toward the least-significant bit, leaving the
most-significant bit unchanged.

3 ( n1 -- n2 ) 
Constant.
 
: ( : “ spaces name” -- colon-sys )
Skip leading space delimiters. Parse name delimited by a space. Create a definition for
name, called a “colon definition”. Enter compilation state and start the current defini-
tion, producing colon-sys. Append the initiation semantics given below to the current
definition.
The execution semantics of name will be determined by the words compiled into the
body of the definition. The current definition shall not be findable in the dictionary until
it is ended (or until the execution of DOES> in some systems).
See also: ; CREATE DOES>

; ( -- )
Append the run-time semantics below to the current definition. End the current definition,
allow it to be found in the dictionary and enter interpretation state, consuming colon-sys.
If the data-space pointer is not aligned, reserve enough data space to align it.
See also: : CREATE DOES>

< ( n1 n2 -- flag )
flag is true if and only if n1 is less than n2.

<# ( -- )
Initialize the pictured numeric output conversion process.
See also: #> # #S

<> ( x1 x2 -- flag )
flag is true if and only if x1 is not bit-for-bit the same as x2.

<BUILDS
TBD

= ( n1 n2 -- flag )
flag is true if and only if n1 is bit-for-bit the same as n2.

> ( n1 n2 -- flag )
flag is true if and only if n1 is greater than n2.

>BODY ( xt -- a-addr )
a-addr is the data-field address corresponding to xt.
An ambiguous condition exists if xt is not for a word defined via CREATE.

>FLOAT ( c-addr u -- true | false ) ( F: -- r | )
An attempt is made to convert the string specified by c-addr and u to internal floating-
point representation. If the string represents a valid floating-point number in the syntax
below, its value r and true are returned.
If the string does not represent a valid floating-point number only false is returned.
A string of blanks should be treated as a special case representing zero.
The syntax of a convertible string is:
   Convertible string := significand exponent
          significand := [ sign ] digits [. digits0 ]
          exponent    := E[ sign ] digits0
          sign        := { + | - }
          digits      := digit digits0
          digits0     := digit *
          digit       := { 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 }
These are examples of valid representations of floating-point numbers in program source:
1. 1.0 1E 1.E 1.E0 +1.23E-1 -1.23E+1 

>NUMBER ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
ud2 is the unsigned result of converting the characters within the string specified by
c-addr1 u1 into digits, using the number in BASE, and adding each into ud1 after multi-
plying ud1 by the number in BASE. Conversion continues left-to-right until a character
that is not convertible, including any “+” or “-”, is encountered or the string is entirely
converted. c-addr2 is the location of the first unconverted character or the first character
past the end of the string if the string was entirely converted. u2 is the number of uncon-
verted characters in the string. An ambiguous condition exists if ud2 overflows during
the conversion.

>R ( x -- ) ( R: -- x )
Move x to the return stack.
See also: R@ R>

?COMP ( -- )
Check that the current => STATE is compiling
otherwise => THROW
often used in control-words

?DUP ( x -- 0 | x x )
Duplicate x if it is non-zero.

?EXEC ( -- )
Check that the current => STATE is executing
otherwise => THROW
often used in control-words

?PAIRS ( a b -- )
If compiling, check that the two magics on
the => CS-STACK are identical, otherwise throw
used in control-words

?STACK ( -- )
Check all stacks for underflow and overflow conditions,
and if such an error condition is detected => THROW

@ ( a-addr -- x )
x is the value stored at a-addr.

ABORT ( i×x -- ) ( R: j×x -- )
Empty the data stack and perform the function of QUIT, which includes emptying the
return stack, without displaying a message.

ABORT" ( “ccc quote ” -- )
Parse ccc delimited by a " (double-quote). Append the run-time semantics given below
to the current definition.

ABS ( n -- u )
u is the absolute value of n.

ACCEPT ( c-addr +n1 -- +n2 )
Receive a string of at most +n1 characters. An ambiguous condition exists if +n1 is
zero or greater than 32,767. Display graphic characters as they are received. A program
that depends on the presence or absence of non-graphic characters in the string has an
environmental dependency. The editing functions, if any, that the system performs in
order to construct the string are implementation-defined.
Input terminates when an implementation-defined line terminator is received. When
input terminates, nothing is appended to the string, and the display is maintained in an
implementation-defined way.
+n2 is the length of the string stored at c-addr.

AGAIN
Compilation: ( C: dest -- )
Append the run-time semantics given below to the current definition, resolving the back-
ward reference dest.
Run-time: ( -- )
Continue execution at the location specified by dest. If no other control flow words are
used, any program code after AGAIN will not be executed.
See also: BEGIN WHILE

ALIGN ( -- )
If the data-space pointer is not aligned, reserve enough space to align it.
See also: ALIGNED

ALIGNED ( addr -- a-addr )
a-addr is the first aligned address greater than or equal to addr.
See also: ALIGN

ALLOT ( n -- )
If n is greater than zero, reserve n address units of data space. If n is less than zero,
release | n | address units of data space. If n is zero, leave the data-space pointer
unchanged.
If the data-space pointer is aligned and n is a multiple of the size of a cell when ALLOT
begins execution, it will remain aligned when ALLOT finishes execution.
If the data-space pointer is character aligned and n is a multiple of the size of a character
when ALLOT begins execution, it will remain character aligned when ALLOT finishes execution.

ALSO ( -- )
Transform the search order consisting of widn, . . . wid2, wid1 (where wid1 is searched
first) into widn, . . . wid2, wid1, wid1. An ambiguous condition exists if there are too many
word lists in the search order.

AND ( x1 x2 -- x3 )
x3 is the bit-by-bit logical "and" of x1 with x2.

AT-XY ( u1 u2 -- )
Perform implementation-dependent steps so that the next character displayed will appear
in column u1, row u2 of the user output device, the upper left corner of which is column
zero, row zero. An ambiguous condition exists if the operation cannot be performed on
the user output device with the specified parameters.

BACKSPACE
TBD

BASE ( -- a-addr )
a-addr is the address of a cell containing the current number-conversion radix {{2...36}}.
See also: HEX DECIMAL

BEGIN
Compilation: ( C: -- dest )
Put the next location for a transfer of control, dest, onto the control flow stack. Append
the run-time semantics given below to the current definition.
Run-time: ( -- )
Continue execution.
See also: REPEAT UNTIL WHILE AGAIN

BL ( -- char )
char is the character value for a space.

BLANK ( c-addr u -- )
If u is greater than zero, store the character value for space in u consecutive character
positions beginning at c-addr.

C! ( char c-addr -- )
Store char at c-addr. When character size is smaller than cell size, only the number of
low-order bits corresponding to character size are transferred.

C" ( -- c-addr )
Compilation: ( “ccc quote ” -- )
Parse ccc delimited by " (double-quote) and append the run-time semantics given below
to the current definition.
Run-time: ( -- c-addr )
Return c-addr, a counted string consisting of the characters ccc. A program shall not
alter the returned string.
See also: S"

C, ( char -- )
Reserve space for one character in the data space and store char in the space. If the data-
space pointer is character aligned when C, begins execution, it will remain character
aligned when C, finishes execution. An ambiguous condition exists if the data-space
pointer is not character-aligned prior to execution of C,.

C@ ( c-addr -- char )
Fetch the character stored at c-addr. When the cell size is greater than character size, the
unused high-order bits are all zeroes.

CASE
Compilation: ( C: -- case-sys )
Mark the start of the CASE. . . OF. . . ENDOF. . . ENDCASE structure. Append the run-time
semantics given below to the current definition.
Run-time: ( -- )
Continue execution.
See also: OF ENDOF ENDCASE

CATCH

CHAR ( “ spaces name” -- char )
Skip leading space delimiters. Parse name delimited by a space. Put the value of its first
character onto the stack.
See also: [CHAR]

CD

CELL+ ( a-addr1 -- a-addr2 )
Add the size in address units of a cell to a-addr1, giving a-addr2.
See also: CELLS CHAR+ CHARS

CELLS ( n1 -- n2 )
n2 is the size in address units of n1 cells.
See also: CELL+ CHAR+ CHARS

CHAR+ ( c-addr1 -- c-addr2 )
Add the size in address units of a character to c-addr1, giving c-addr2.
See also: CELL+ CELLS CHARS

CHARS ( n1 -- n2 )
n2 is the size in address units of n1 characters.
See also: CELL+ CELLS CHAR+

CLOSE-FILE

CMOVE ( c-addr1 c-addr2 u -- )
If u is greater than zero, copy u consecutive characters from the data space starting at c-addr1 to that
starting at c-addr2, proceeding character-by-character from lower addresses to higher addresses.
See also: CMOVE> MOVE

CMOVE> ( c-addr1 c-addr2 u -- )
If u is greater than zero, copy u consecutive characters from the data space starting at c-addr1 to that
starting at c-addr2, proceeding character-by-character from higher addresses to lower addresses.
See also: CMOVE MOVE

COLS ( -- n )
Return the number of columns on the screen.
See also: COLS

COMPILE,

CONSTANT ( x “ spaces name” -- )
Skip leading space delimiters. Parse name delimited by a space. Create a definition for
name with the execution semantics defined below. name is referred to as a “constant”.
Execution: ( -- x )
Place x on the stack.

CONTEXT
TBD

COUNT ( c-addr1 -- c-addr2 u )
Return the character string specification for the counted string stored at c-addr1. c-addr2
is the address of the first character after c-addr1. u is the contents of the character at
c-addr1, which is the length in characters of the string at c-addr2.

CR ( -- )
Cause subsequent output to appear at the beginning of the next line.

CREATE ( “ spaces name” -- )
Skip leading space delimiters. Parse name delimited by a space. Create a definition
for name with the execution semantics defined below. If the data-space pointer is not
aligned, reserve enough data space to align it. The new data-space pointer defines name’s
data field. CREATE does not allocate data space in name’s data field.
name Execution: ( -- a-addr )
a-addr is the address of name’s data field. The execution semantics of name may be
extended by using DOES>.
See also: DOES>

CREATE-FILE

CURRENT

DEBUG

DECIMAL ( -- )
Set BASE to ten.

DEFINITIONS ( -- )
Make the compilation word list the same as the first word list in the search order. Speci-
fies that the names of subsequent definitions will be placed in the compilation word list.
Subsequent changes in the search order will not affect the compilation word list.

DELETE-FILE

DEPTH ( -- +n )
+n is the number of single-cell values contained in the data stack before +n was placed on the stack.
See also: FDEPTH

DO ( n1 n2 -- ) ( R: -- loop-sys )
Set up loop control parameters with index n2 and limit n1 . An ambiguous
condition exists if n1 and n2 are not both the same type. Anything already on the
return stack becomes unavailable until the loop-control parameters are discarded.
See also: +LOOP LOOP DO LEAVE

DOES>
Compilation: ( C: colon-sys1 -- colon-sys2 )
Append the run-time semantics below to the current definition. Whether or not the cur-
rent definition is rendered findable in the dictionary by the compilation of DOES> is
implementation defined. Consume colon-sys1 and produce colon-sys2. Append the initi-
ation semantics given below to the current definition.
Run-time: ( -- ) ( R: nest-sys1 -- )
Replace the execution semantics of the most recent definition, referred to as name, with
the name execution semantics given below. Return control to the calling definition spec-
ified by nest-sys1. An ambiguous condition exists if name was not defined with CREATE
or a user-defined word that calls CREATE.
Initiation: ( i×x -- i×x a-addr ) ( R: -- nest-sys2 )
Save implementation-dependent information nest-sys2 about the calling definition. Place
name’s data field address on the stack. The stack effects i×x represent arguments to
name.
name Execution: ( i×x -- j×x )
Execute the portion of the definition that begins with the initiation semantics appended
by the DOES> which modified name. The stack effects i×x and j×x represent arguments
to and results from name, respectively.
See also: CREATE

DROP ( x -- )
Remove x from the stack.

DUMP ( addr u -- )
Display the contents of u consecutive addresses starting at addr. The format of the
display is implementation dependent.

DUP ( x -- x x )
Duplicate x.

ELSE
Compilation: ( C: orig1 -- orig2 )
Put the location of a new unresolved forward reference orig2 onto the control flow stack.
Append the run-time semantics given below to the current definition. The semantics
will be incomplete until orig2 is resolved (e.g., by THEN). Resolve the forward reference
orig1 using the location following the appended run-time semantics.
Run-time: ( -- )
Continue execution at the location given by the resolution of orig2.
See also: IF THEN

EMIT ( x -- )
If x is a graphic character in the implementation-defined character set, display x. The
effect of EMIT for all other values of x is implementation-defined.
See also: TYPE

ENDCASE
Compilation: ( C: case-sys -- )
Mark the end of the CASE. . . OF. . . ENDOF. . . ENDCASE structure. Use case-sys to re-
solve the entire structure. Append the run-time semantics given below to the current
definition.
Run-time: ( x -- )
Discard the case selector x and continue execution.
See also: CASE OF ENDOF

ENDOF
Compilation: ( C: case-sys1 of-sys -- case-sys2 )
Mark the end of the OF. . . ENDOF part of the CASE structure. The next location for a
transfer of control resolves the reference given by of-sys. Append the run-time semantics
given below to the current definition. Replace case-sys1 with case-sys2 on the control-
flow stack, to be resolved by ENDCASE.
See also: CASE OF ENDCASE

ERASE ( addr u -- )
If u is greater than zero, clear all bits in each of u consecutive address units of memory
beginning at addr.

EXECUTE ( i×x xt -- j×x )
Remove xt from the stack and perform the semantics identified by it. Other stack effects
are due to the word EXECUTEd.
See also: '

EXIT ( -- ) ( R: nest-sys -- )
Return control to the calling definition specified by nest-sys. Before executing EXIT
within a do-loop, a program shall discard the loop-control parameters by executing UNLOOP.
See also: UNLOOP

F. ( -- ) ( F: r -- )
Display, with a trailing space, the top number on the floating-point stack using fixed-point notation:
    [-] digits . digits0
The value of BASE is ignored.
See also: >FLOAT FE. FS. PRECISION

F! ( f-addr -- ) ( F: r -- )
Store r at f-addr.

F* ( F: r1 r2 -- r3 )
Multiply r1 by r2 giving r3.

F** ( F: r1 r2 -- r3 )
Raise r1 to the power r2, giving the product r3.

F+ ( F: r1 r2 -- r3 )
Add r1 to r2 giving the sum r3.

F- ( F: r1 r2 -- r3 )
Subtract r2 from r1, giving r3.

F/ ( F: r1 r2 -- r3 )
Divide r1 by r2, giving the quotient r3. An ambiguous condition exists if r2 is zero, or the
quotient lies outside of the range of a floating-point number.

F0< ( -- flag ) ( F: r -- )
flag is true if and only if r is less than zero.

F0= ( -- flag ) ( F: r -- )
flag is true if and only if r is equal to zero.

F< ( -- flag ) ( F: r1 r2 -- )
flag is true if and only if r1 is less than r2.

F>S ( -- x ) ( F: r -- )
x is the signed-integer equivalent of the integer portion of r. The fractional portion of r is discarded.
An ambiguous condition exists if the integer portion of r cannot be represented as a signed integer.
Note: Rounding the floating-point value prior to calling F>S is advised, because F>S rounds towards zero.

F@ ( f-addr -- ) ( F: -- r )
r is the value stored at f-addr.

FALIGN ( -- )
If the data-space pointer is not float aligned, reserve enough data space to make it so.

FALIGNED ( addr -- f-addr )
f-addr is the first float-aligned address greater than or equal to addr.

FALSE ( -- false )
Return a false flag.

FCONSTANT ( “ spaces name” -- ) ( F: r -- )
Skip leading space delimiters. Parse name delimited by a space. Create a definition for
name with the execution semantics defined below.
name is referred to as an “f-constant”.
Execution: ( -- ) ( F: -- r )
Place r on the floating-point stack.

FDEPTH ( -- +n )
+n is the number of values contained on the floating-point stack. If the system has an
environmental restriction of keeping the floating-point numbers on the data stack, +n is
the current number of possible floating-point values contained on the data stack.
See also: DEPTH

FDROP ( F: r -- )
Remove r from the floating-point stack.

FDUP ( F: r -- r r )
Duplicate r.

FE. ( -- ) ( F: r -- )
Display, with a trailing space, the top number on the floating-point stack using engineering notation,
where the significand is greater than or equal to 1.0 and less than 1000.0 and the decimal exponent is
a multiple of three.
The value of BASE is ignored.
See also: >FLOAT F. FS. PRECISION

FILE-POSITION

FILE-SIZE

FILE-STATUS

FILL ( c-addr u char -- )
If u is greater than zero, store char in each of u consecutive characters of memory beginning at c-addr.

FIND ( c-addr -- c-addr 0 | xt 1 | xt -1 )
Find the definition named in the counted string at c-addr. If the definition is not found,
return c-addr and zero. If the definition is found, return its execution token xt. If the
definition is immediate, also return one (1), otherwise also return minus-one (-1). For
a given string, the values returned by FIND while compiling may differ from those re-
turned while not compiling.
See also: '

FLITERAL
Compilation: ( F: r -- ) or ( r -- )
Append the run-time semantics given below to the current definition.
Run-time: ( F: -- r ) or ( -- r )
Place r on the floating-point stack.

FLOAT+
( f-addr1 -- f-addr2 )
Add the size in address units of a floating-point number to f-addr1, giving f-addr2.

FLOATS ( n1 -- n2 )
n2 is the size in address units of n1 floating-point numbers.

FLOOR ( F: r1 -- r2 )
Round r1 to an integral value using the “round toward negative infinity” rule, giving r2.

FLUSH-FILE

FMAX ( F: r1 r2 -- r3 )
r3 is the greater of r1 and r2.

FMIN ( F: r1 r2 -- r3 )
r3 is the lesser of r1 and r2.

FNEGATE ( F: r1 -- r2 )
r2 is the negation of r1.

FOPEN ( name-ptr name-len mode-ptr mode-len -- FILE* )

 * as FILE *fopen(const char *path, const char *mode);
 * mode:
       r      Open text file for reading.  The stream is positioned at the beginning of the file.
       r+     Open for reading and writing.  The stream is positioned at the beginning of the file.
       w      Truncate file to zero length or create text file for writing.  The stream is positioned at the beginning of the file.
       w+     Open for reading and writing.  The file is created if it does not exist, otherwise it is truncated.  The stream is  positioned
              at the beginning of the file.
       a      Open  for  appending (writing at end of file).  The file is created if it does not exist.  The stream is positioned at the end
              of the file.
       a+     Open for reading and appending (writing at end of file).  The file is created if it does not exist.  The initial file position
              for reading is at the beginning of the file, but output is always appended to the end of the file.
See also: '

/** FGETC ( FILE* -- c )
 * as int fgetc(FILE *stream);
       fgetc() returns the character read as an unsigned char cast to an int or EOF on end of file or error.
 */

/** FGETS ( buffer len FILE* -- len )
 * as char *fgets(char *s, int size, FILE *stream);
       fgets() returns s on success, and NULL on error or when end of file occurs while no characters have been read.

/** FPUTC ( c FILE* -- result )
 * as int fputc(int c, FILE *stream);
      fputc() returns the character written as an unsigned char cast to an int or EOF on error.

/** FPUTS ( string len FILE* -- result )
 * as int fputs(const char *s, FILE *stream);
      fputs() returns a nonnegative number on success, or EOF on error.
 */
/** FCLOSE ( FILE* -- )
 * as fclose(FILE *fp);
 */

/** ERRNO ( -- errno )
 */



FORTH ( -- )
Transform the search order consisting of widn, . . . wid2, wid1 (where wid1 is searched
first) into widn, . . . wid2, wid(FORTH-WORDLIST).

FORTH-SIGNAL

FORTH-WORDLIST ( -- wid )
Return wid, the identifier of the word list that includes all standard words provided by
the implementation. This word list is initially the compilation word list and is part of the
initial search order.

FOVER ( F: r1 r2 -- r1 r2 r1 )
Place a copy of r1 on top of the floating-point stack.

FROT ( F: r1 r2 r3 -- r2 r3 r1 )
Rotate the top three floating-point stack entries.

FROUND ( F: r1 -- r2 )
Round r1 to an integral value using the “round to nearest” rule, giving r2.

FS. ( -- ) ( F: r -- )
Display, with a trailing space, the top number on the floating-point stack in scientific notation,
significand exponent where:
    significand := [-] digit . digits0
    exponent := E[-] digits
The value of BASE is ignored.
See also: >FLOAT F. FE. PRECISION

FSWAP ( F: r1 r2 -- r2 r1 )
Exchange the top two floating-point stack items.

FVARIABLE ( “ spaces name” -- )
Skip leading space delimiters. Parse name delimited by a space. Create a definition for
name with the execution semantics defined below. Reserve 1 FLOATS address units of
data space at a float-aligned address.
name is referred to as an “f-variable”.
Execution: ( -- f-addr )
f-addr is the address of the data space reserved by FVARIABLE when it created name.
A program is responsible for initializing the contents of the reserved space.

HELP ( " spaces name" -- xt )
Skip leading space delimiters. Parse name delimited by a space. Display name help.

HERE ( -- addr )
addr is the data-space pointer.

HEX ( -- )
Set BASE to sixteen.

HOLD ( char -- )
Add char to the beginning of the pictured numeric output string.
An ambiguous condition exists if HOLD executes outside of a <# #> delimited number conversion.

I ( -- n | u ) ( R: loop-sys -- loop-sys )
n | u is a copy of the current (innermost) loop index.
An ambiguous condition exists if the loop control parameters are unavailable.
See also: DO LOOP +LOOP J

IF
Compilation: ( C: -- orig )
Put the location of a new unresolved forward reference orig onto the control flow stack.
Append the run-time semantics given below to the current definition. The semantics are
incomplete until orig is resolved, e.g., by THEN or ELSE.
Run-time: ( x -- )
If all bits of x are zero, continue execution at the location specified by the resolution of orig.
See also: ELSE THEN

IMMEDIATE ( -- )
Make the most recent definition an immediate word.

INCLUDE

INCLUDED

INVERT ( x1 -- x2 )
Invert all bits of x1, giving its logical inverse x2.
See also: 0= NEGATE NOT

J ( -- n | u ) ( R: loop-sys1 loop-sys2 -- loop-sys1 loop-sys2 )
n | u is a copy of the next-outer loop index. An ambiguous condition exists if the loop
control parameters of the next-outer loop, loop-sys1, are unavailable.
See also: DO LOOP +LOOP I

KEY ( -- char )
Receive one character char, a member of the implementation-defined character set.
Keyboard events that do not correspond to such characters are discarded until a valid
character is received, and those events are subsequently unavailable.
All standard characters can be received. Characters received by KEY are not displayed.

KEY? ( -- flag )
If a character is available, return true. Otherwise, return false. If non-character keyboard
events are available before the first valid character, they are discarded and are subse-
quently unavailable. The character shall be returned by the next execution of KEY.
After KEY? returns with a value of true, subsequent executions of KEY? prior to the
execution of KEY or EKEY also return true, without discarding keyboard events.
See also: KEY

LATEST ( -- nfa )
NFA of the last created name.

LEAVE ( -- ) ( R: loop-sys -- )
Discard the current loop control parameters. An ambiguous condition exists if they are unavailable.
Continue execution immediately following the innermost syntactically
enclosing DO. . . LOOP or DO. . . +LOOP.
See also: DO LOOP +LOOP

LITERAL
Compilation: ( x -- )
Append the run-time semantics given below to the current definition.
Run-time: ( -- x )
Place x on the stack.

LL

LOAD-SIGNALS

LS

MARKER

MAX ( n1 n2 -- n3 )
n3 is the greater of n1 and n2.
See also: MIN

MIN ( n1 n2 -- n3 )
n3 is the lesser of n1 and n2.
See also: MAX

MKDIR

MOD ( n1 n2 -- n3 )
Divide n1 by n2, giving the single-cell remainder n3.
An ambiguous condition exists if n2 is zero.

MORE ( -- )
Initialize a more-like effect, stop display at the end of screen.
See also: MORE?

MORE? ( -- flag )
Like CR but stop after one screenful.
Return 1 when 'q' or 'n' is pressed and 0 when CR, SPACE or 'y' is pressed.
Press 'h' to display a little help.
See also: MORE

MOVE ( addr1 addr2 u -- )
If u is greater than zero, copy the contents of u consecutive address units at addr1
to the u consecutive address units at addr2. After MOVE completes, the u consecutive
address units at addr2 contain exactly what the u consecutive address units at addr1
contained before the move (deal with overlapping regions).
See also: CMOVE CMOVE>

MS ( u -- )
Wait at least u milliseconds.
Note: The actual length and variability of the time period depends upon the implementation
defined resolution of the system clock and upon other system and computer characteristics
beyond the scope of this standard.

NEGATE ( n1 -- n2 )
Negate n1, giving its arithmetic inverse n2.
See also: 0= INVERT NOT

NIP ( x1 x2 -- x2 )
Drop the first item below the top of stack.
See also: TUCK

NO-DEBUG

NOT ( x1 -- x2 )
Invert all bits of x1, giving its logical inverse x2.
Synonym of INVERT
See also: 0= INVERT NEGATE

OF
Compilation: ( C: -- of-sys )
Put of-sys onto the control flow stack. Append the run-time semantics given below to the
current definition. The semantics are incomplete until resolved by a consumer of of-sys
such as ENDOF.
Run-time: ( x1 x2 -- x1 )
If the two values on the stack are not equal, discard the top value and continue execution
at the location specified by the consumer of of-sys, e.g., following the next ENDOF.
Otherwise, discard both values and continue execution in line.
See also: CASE OF ENDCASE

ONLY ( -- )
Set the search order to the implementation-defined minimum search order.
The minimum search order shall include the words FORTH-WORDLIST and SET-ORDER.

OPEN-FILE

OR ( x1 x2 -- x3 )
x3 is the bit-by-bit inclusive-or of x1 with x2.

ORDER ( -- )
Display the word lists in the search order in their search order sequence, from first
searched to last searched. Also display the word list into which new definitions will
be placed. The display format is implementation dependent.
ORDER may be implemented using pictured numeric output words. Consequently, its
use may corrupt the transient region identified by #>.

OVER ( x1 x2 -- x1 x2 x1 )
Place a copy of x1 on top of the stack.

PAD ( -- c-addr )
c-addr is the address of a transient region that can be used to hold data for intermediate
processing.

PICK ( xu. . . x1 x0 u -- xu. . . x1 x0 xu )
Remove u. Copy the xu to the top of the stack. An ambiguous condition exists if there
are less than u+2 items on the stack before PICK is executed.

PRECISION ( -- u )
Return the number of significant digits currently used by F., FE., or FS. as u.
See also: F. FE. FS. SET-PRECISION

PWD

R/O

R/W               

R> ( -- x ) ( R: x -- )
Move x from the return stack to the data stack.
See also: >R R@

R@ ( -- x ) ( R: x -- x )
Copy x from the return stack to the data stack.
See also: >R R>

RAISE-SIGNAL

READ-FILE         

READ-LINE

RECURSE
Compilation: ( -- )
Append the execution semantics of the current definition to the current definition. An
ambiguous condition exists if RECURSE appears in a definition after DOES>.

REPEAT
Compilation: ( C: orig dest -- )
Append the run-time semantics given below to the current definition, resolving the back-
ward reference dest. Resolve the forward reference orig using the location following the
appended run-time semantics.
Run-time: ( -- )
Continue execution at the location given by dest.
See also: BEGIN WHILE AGAIN

REPOSITION-FILE

REPRESENT ( c-addr u -- n flag1 flag2 ) ( F: r -- )
At c-addr, place the character-string external representation of the significand of the
floating-point number r. Return the decimal-base exponent as n, the sign as flag1 and
“valid result” as flag2. The character string shall consist of the u most significant digits
of the significand represented as a decimal fraction with the implied decimal point to the
left of the first digit, and the first digit zero only if all digits are zero. The significand
is rounded to u digits following the “round to nearest” rule; n is adjusted, if necessary,
to correspond to the rounded magnitude of the significand.
If flag2 is true then r was in the implementation-defined range of floating-point numbers.
If flag1 is true then r is negative.
An ambiguous condition exists if the value of BASE is not decimal ten.
When flag2 is false, n and flag1 are implementation defined, as are the contents of c-addr.
Under these circumstances, the string at c-addr shall consist of graphic characters.

RESIZE-FILE

RM

ROLL ( xu xu-1 . . . x0 u -- xu-1 . . . x0 xu )
Remove u. Rotate u+1 items on the top of the stack. An ambiguous condition exists if
there are less than u+2 items on the stack before ROLL is executed.

ROT ( x1 x2 x3 -- x2 x3 x1 )
Rotate the top three stack entries.

ROWS ( -- n )
Return the number of rows on the screen.
See also: COLS

S>F ( x -- ) ( F: -- r )
r is the floating-point equivalent of x.
An ambiguous condition exists if x cannot be precisely represented as a floating-point value.

S" ( -- c-addr u )
Compilation: ( “ccc quote ” -- )
Parse ccc delimited by " (double-quote). Append the run-time semantics given below to
the current definition.
Run-time: ( -- c-addr u )
Return c-addr and u describing a string consisting of the characters ccc. A program shall
not alter the returned string.
See also: C"

SEE ( “ spaces name” -- )
Display a human-readable representation of the named word’s definition. The source
of the representation (object-code decompilation, source block, etc.) and the particular
form of the display is implementation defined.
SEE may be implemented using pictured numeric output words. Consequently, its use
may corrupt the transient region identified by #>.

SET-PRECISION ( u -- )
Set the number of significant digits currently used by F., FE., or FS. to u.
See also: F. FE. FS. PRECISION

SIGN ( n -- )
If n is negative, add a minus sign to the beginning of the pictured numeric output string.
An ambiguous condition exists if SIGN executes outside of a <# #> delimited number conversion.

SOURCE ( -- c-addr u )
c-addr is the address of, and u is the number of characters in, the input buffer.

SPACE ( -- )
Display one space.
See also: SPACES

SPACES ( n -- )
If n is greater than zero, display n spaces.
See also: SPACE

STATE ( -- a-addr )
a-addr is the address of a cell containing the compilation-state flag. STATE is true
when in compilation state, false otherwise. The true value in STATE is non-zero, but is
otherwise implementation-defined. Only the following standard words alter the value in
STATE: : (colon), ; (semicolon), ABORT, QUIT, :NONAME, [ (left-bracket), ] (right-bracket).
Note: A program shall not directly alter the contents of STATE.

SWAP ( x1 x2 -- x2 x1 )
Exchange the top two stack items.

SYSTEM

THEN
Compilation: ( C: orig -- )
Append the run-time semantics given below to the current definition. Resolve the for-
ward reference orig using the location of the appended run-time semantics.
Run-time: ( -- )
Continue execution
See also: IF THEN

THROW

TIME&DATE ( -- +n1 +n2 +n3 +n4 +n5 +n6 )
Return the current time and date.
+n1 is the second {0. . . 59}, +n2 is the minute {0. . . 59}, +n3 is the hour {0. . . 23},
+n4 is the day {1. . . 31}, +n5 is the month {1. . . 12} and +n6 is the year (e.g., 1991).

TO
Interpretation: ( i×x “ spaces name” -- )
Skip leading spaces and parse name delimited by a space. Perform the “TO name run-
time” semantics given in the definition for the defining word of name. An ambiguous
condition exists if name was not defined by a word with “TO name run-time” semantics.
Compilation: ( “ spaces name” -- )
Skip leading spaces and parse name delimited by a space. Append the “TO name run-
time” semantics given in the definition for the defining word of name to the current
definition. An ambiguous condition exists if name was not defined by a word with “TO
name run-time” semantics.
Run-time: ( -- )
See also: VALUE

TOUCH

TRUE ( -- true )
Return a true flag, a single-cell value with all bits set.

TUCK
( x1 x2 -- x2 x1 x2 )
Copy the first (top) stack item below the second stack item.
See also: NIP

TYPE ( c-addr u -- )
If u is greater than zero, display the character string specified by c-addr and u.
See also: EMIT

UMASK

UNLOOP ( -- ) ( R: loop-sys -- )
Discard the loop-control parameters for the current nesting level.
An UNLOOP is required for each nesting level before the definition may be EXITed.
An ambiguous condition exists if the loop-control parameters are unavailable.
See also: DO LOOP

UNTIL Compilation: ( C: dest -- )
Append the run-time semantics given below to the current definition, resolving the back-
ward reference dest.
Run-time: ( x -- )
If all bits of x are zero, continue execution at the location specified by dest.
See also: BEGIN

VALUE ( x “ spaces name” -- )
Skip leading space delimiters. Parse name delimited by a space. Create a definition for
name with the execution semantics defined below, with an initial value equal to x.
name is referred to as a “value”.
name Execution: ( -- x )
Place x on the stack. The value of x is that given when name was created, until the phrase
x TO name is executed, causing a new value of x to be assigned to name.
See also: TO

VARIABLE ( “ spaces name” -- )
Skip leading space delimiters. Parse name delimited by a space. Create a definition for
name with the execution semantics defined below. Reserve one cell of data space at an
aligned address.
name is referred to as a “variable”.
name Execution: ( -- a-addr )
a-addr is the address of the reserved cell. A program is responsible for initializing the
contents of the reserved cell.

VOCABULARY

W/O

WHILE
Compilation: ( C: dest -- orig dest )
Put the location of a new unresolved forward reference orig onto the control flow stack,
under the existing dest. Append the run-time semantics given below to the current defi-
nition. The semantics are incomplete until orig and dest are resolved (e.g., by REPEAT).
Run-time: ( x -- )
If all bits of x are zero, continue execution at the location specified by the resolution of orig.
See also: BEGIN AGAIN REPEAT

WITHIN ( n1 n2 n3 -- flag )
Perform a comparison of a test value n1 with a lower limit n2 and an upper limit n3,
returning true if either (n2 < n3 and (n2 <= n1 and n1 < n3))
or (n2 > n3 and (n2 <= n1 or n1 < n3)) is true, returning false otherwise.

WORDS ( -- )
List the definition names in the first word list of the search order. The format of the
display is implementation-dependent.
WORDS may be implemented using pictured numeric output words. Consequently, its
use may corrupt the transient region identified by #>.

WRITE-FILE        

WRITE-LINE

XOR ( x1 x2 -- x3 )
x3 is the bit-by-bit exclusive-or of x1 with x2.

[ ( -- )
Enter interpretation state. [ is an immediate word.
See also: ]

[']
Compilation: ( “ spaces name” -- )
Skip leading space delimiters. Parse name delimited by a space. Find name. Append the
run-time semantics given below to the current definition.
An ambiguous condition exists if name is not found.
Run-time: ( -- xt )
Place name’s execution token xt on the stack. The execution token returned by the com-
piled phrase “[’] X” is the same value returned by “’ X” outside of compilation state.
See also: FIND ’

[CHAR]
Compilation: ( “ spaces name” -- )
Skip leading space delimiters. Parse name delimited by a space. Append the run-time
semantics given below to the current definition.
Run-time: ( -- char )
Place char, the value of the first character of name, on the stack.
See also: CHAR [ ]

[COMPILE]
Compilation: ( “ spaces name” -- )
Skip leading space delimiters. Parse name delimited by a space. Find name. If name has
other than default compilation semantics, append them to the current definition; other-
wise append the execution semantics of name. An ambiguous condition exists if name is
not found.

\ ( “ccc eol ” -- )
Comment
Parse and discard the remainder of the parse area. \ is an immediate word.
See also: (

] ( -- )
Enter compilation state.
See also: [


File-Access words
-----------------
( is not conform, doesn't refill the input buffer; ) must be on the same line.
INCLUDE-FILE is not implemented.
S" is not conform.
SOURCE-ID is not implemented.


BIN ( fam1 -- fam2 )
Modify the implementation-defined file access method fam1 to additionally select a
“binary”, i.e., not line oriented, file access method, giving access method fam2.
See also: R/O R/W W/O

CLOSE-FILE ( fileid -- ior )
Close the file identified by fileid. ior is the implementation-defined I/O result code.

CREATE-FILE ( c-addr u fam -- fileid ior )
Create the file named in the character string specified by c-addr and u, and open it with
file access method fam. The meaning of values of fam is implementation defined. If a
file with the same name already exists, recreate it as an empty file.
If the file was successfully created and opened, ior is zero, fileid is its identifier, and the
file has been positioned to the start of the file.
Otherwise, ior is the implementation-defined I/O result code and fileid is undefined.
See also: OPEN-FILE

DELETE-FILE ( c-addr u -- ior )
Delete the file named in the character string specified by c-addr u. ior is the implement-
ation-defined I/O result code.

FILE-POSITION ( fileid -- ud ior )
ud is the current file position for the file identified by fileid. ior is the implementation-
defined I/O result code. ud is undefined if ior is non-zero.

FILE-SIZE ( fileid -- ud ior )
ud is the size, in characters, of the file identified by fileid. ior is the implementation-
defined I/O result code. This operation does not affect the value returned by FILE-
POSITION. ud is undefined if ior is non-zero.

INCLUDED ( i×x c-addr u -- j×x )
Remove c-addr u from the stack. Save the current input source specification, including
the current value of SOURCE-ID. Open the file specified by c-addr u, store the resulting
fileid in SOURCE-ID, and make it the input source. Store zero in BLK. Other stack
effects are due to the words included.
Repeat until end of file: read a line from the file, fill the input buffer from the contents
of that line, set >IN to zero, and interpret.
Text interpretation begins at the start of the file.
When the end of the file is reached, close the file and restore the input source specification
to its saved value.
An ambiguous condition exists if the named file can not be opened, if an I/O excep-
tion occurs reading the file, or if an I/O exception occurs while closing the file. When
an ambiguous condition exists, the status (open or closed) of any files that were being
interpreted is implementation-defined.
INCLUDED may allocate memory in data space before it starts interpreting the file.

OPEN-FILE ( c-addr u fam -- fileid ior )
Open the file named in the character string specified by c-addr u, with file access method
indicated by fam. The meaning of values of fam is implementation defined.
If the file is successfully opened, ior is zero, fileid is its identifier, and the file has been
positioned to the start of the file.
Otherwise, ior is the implementation-defined I/O result code and fileid is undefined.

R/O ( -- fam )
fam is the implementation-defined value for selecting the “read only” file access method.

R/W ( -- fam )
fam is the implementation-defined value for selecting the “read/write” file access method.

READ-FILE ( c-addr u1 fileid -- u2 ior )
Read u1 consecutive characters to c-addr from the current position of the file identified
by fileid.
If u1 characters are read without an exception, ior is zero and u2 is equal to u1.
If the end of the file is reached before u1 characters are read, ior is zero and u2 is the
number of characters actually read.
If the operation is initiated when the value returned by FILE-POSITION is equal to the
value returned by FILE-SIZE for the file identified by fileid, ior is zero and u2 is zero.
If an exception occurs, ior is the implementation-defined I/O result code, and u2 is the
number of characters transferred to c-addr without an exception.
An ambiguous condition exists if the operation is initiated when the value returned by
FILE-POSITION is greater than the value returned by FILE-SIZE for the file iden-
tified by fileid, or if the requested operation attempts to read portions of the file not
written.
At the conclusion of the operation, FILE-POSITION returns the next file position after
the last character read.
See also: READ-LINE WRITE-FILE WRITE-LINE

READ-LINE ( c-addr u1 fileid -- u2 flag ior )
Read the next line from the file specified by fileid into memory at the address c-addr. At
most u1 characters are read. Up to two implementation-defined line-terminating charac-
ters may be read into memory at the end of the line, but are not included in the count u2.
The line buffer provided by c-addr should be at least u1+2 characters long.
If the operation succeeded, flag is true and ior is zero. If a line terminator was received
before u1 characters were read, then u2 is the number of characters, not including the line
terminator, actually read (0 <= u2 <= u1). When u1 = u2 the line terminator has yet to
be reached.
If the operation is initiated when the value returned by FILE-POSITION is equal to the
value returned by FILE-SIZE for the file identified by fileid, flag is false, ior is zero,
and u2 is zero. If ior is non-zero, an exception occurred during the operation and ior is
the implementation-defined I/O result code.
An ambiguous condition exists if the operation is initiated when the value returned by
FILE-POSITION is greater than the value returned by FILE-SIZE for the file iden-
tified by fileid, or if the requested operation attempts to read portions of the file not
written.
At the conclusion of the operation, FILE-POSITION returns the next file position after
the last character read.
See also: READ-FILE WRITE-FILE WRITE-LINE

REPOSITION-FILE ( ud fileid -- ior )
Reposition the file identified by fileid to ud. ior is the implementation-defined I/O result
code. An ambiguous condition exists if the file is positioned outside the file boundaries.
At the conclusion of the operation, FILE-POSITION returns the value ud.

RESIZE-FILE ( ud fileid -- ior )
Set the size of the file identified by fileid to ud. ior is the implementation-defined I/O result code.
If the resultant file is larger than the file before the operation, the portion of the file added
as a result of the operation might not have been written.
At the conclusion of the operation, FILE-SIZE returns the value ud and FILE-
POSITION returns an unspecified value.

W/O ( -- fam )
fam is the implementation-defined value for selecting the “write only” file access method.

WRITE-FILE ( c-addr u fileid -- ior )
Write u characters from c-addr to the file identified by fileid starting at its current posi-
tion. ior is the implementation-defined I/O result code.
At the conclusion of the operation, FILE-POSITION returns the next file position after
the last character written to the file, and FILE-SIZE returns a value greater than or
equal to the value returned by FILE-POSITION.
See also: READ-FILE READ-LINE WRITE-LINE

WRITE-LINE ( c-addr u fileid -- ior )
Write u characters from c-addr followed by the implementation-dependent line termina-
tor to the file identified by fileid starting at its current position. ior is the implementation-
defined I/O result code.
At the conclusion of the operation, FILE-POSITION returns the next file position after
the last character written to the file, and FILE-SIZE returns a value greater than or
equal to the value returned by FILE-POSITION.
See also: READ-FILE READ-LINE WRITE-FILE


File-Access extension words
---------------------------

FILE-STATUS ( c-addr u -- x ior )
Return the status of the file identified by the character string c-addr u. If the file ex-
ists, ior is zero; otherwise ior is the implementation-defined I/O result code. x contains
implementation-defined information about the file.

FLUSH-FILE ( fileid -- ior )
Attempt to force any buffered information written to the file referred to by fileid to be
written to mass storage, and the size information for the file to be recorded in the storage
directory if changed. If the operation is successful, ior is zero. Otherwise, it is an
implementation-defined I/O result code.

INCLUDE ( i×x “name” -- j×x )
Skip leading white space and parse name delimited by a white space character. Push the
address and length of the name on the stack and perform the function of INCLUDED.


File-Access my extension words
------------------------------
Similar to C functions

FCLOSE ( FILE* -- )
Flushes the stream and closes the underlying file descriptor.

ERRNO ( -- errno )
Returns error number of the last system call.
Its value is significant only when the return value of the call indicated an error
(i.e., -1 from most system calls; -1 or NULL from most library functions); a function that succeeds is allowed to change errno.
Valid error numbers are all nonzero; errno is never set to zero by any system call or library function.

FGETC ( FILE* -- c )
Reads the next character from stream and returns it as an unsigned char cast to an int, or EOF on end of file or error.
Returns the character read as an unsigned char cast to an int or EOF on end of file or error.

FGETS ( buffer len FILE* -- len )
Reads in at most one less than len characters from stream and stores them into the buffer.
Reading  stops after an EOF or a newline. If a newline is read, it is stored into the buffer.
A terminating null byte ('\0') is stored after the last character in the buffer.
Returns s on success, and NULL on error or when end of file occurs while no characters have been read.

FOPEN ( name-ptr name-len mode-ptr mode-len -- FILE* )
Open the file named in the character string specified by name-ptr name-len, with mode specified by mode-ptr mode-len.
Returns a pointer to a FILE structure or NULL.
Same as "FILE *fopen(const char *path, const char *mode);"
mode strings are:
       r      Open text file for reading.  The stream is positioned at the beginning of the file.
       r+     Open for reading and writing.  The stream is positioned at the beginning of the file.
       w      Truncate file to zero length or create text file for writing.  The stream is positioned at the beginning of the file.
       w+     Open for reading and writing.  The file is created if it does not exist, otherwise it is truncated.  The stream is  positioned
              at the beginning of the file.
       a      Open  for  appending (writing at end of file).  The file is created if it does not exist.  The stream is positioned at the end
              of the file.
       a+     Open for reading and appending (writing at end of file).  The file is created if it does not exist.  The initial file position
              for reading is at the beginning of the file, but output is always appended to the end of the file.
Example: "/tmp/plop" "a+" fopen

FPUTC ( c FILE* -- result )
Writes the character c, cast to an unsigned char, to stream.
Returns the character written as an unsigned char cast to an int or EOF on error.

FPUTS ( string len FILE* -- result )
Writes the string s to stream, without its terminating null byte ('\0').
Returns a nonnegative number on success, or EOF on error.

